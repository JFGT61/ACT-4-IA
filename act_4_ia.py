# -*- coding: utf-8 -*-
"""Act 4 IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hNVojqlaHJt3vjmy9r4GkHj451fzNNWT
"""

import heapq

from sklearn.cluster import KMeans

import numpy as np

#--------------------------------

class Grafo:

    def __init__(self):

        self.vertices = {}



    def agregar_vertice(self, vertice):

        self.vertices[vertice] = {}



    def agregar_arista(self, origen, destino, peso):

        self.vertices[origen][destino] = peso

        self.vertices[destino][origen] = peso



    def obtener_vecinos(self, vertice):

        return self.vertices[vertice]



class SistemaTransporte:

    def __init__(self, grafo):

        self.grafo = grafo



    def encontrar_ruta(self, origen, destino):

        cola_prioridad = []

        heapq.heappush(cola_prioridad, (0, origen))

        visitados = set()

        padres = {}

        distancias = {vertice: float('inf') for vertice in self.grafo.vertices}

        distancias[origen] = 0



        while cola_prioridad:

            distancia_actual, vertice_actual = heapq.heappop(cola_prioridad)



            if vertice_actual == destino:

                ruta_optima = []

                while vertice_actual in padres:

                    ruta_optima.append(vertice_actual)

                    vertice_actual = padres[vertice_actual]

                ruta_optima.append(origen)

                return ruta_optima[::-1]



            if vertice_actual in visitados:

                continue



            visitados.add(vertice_actual)



            for vecino, peso in self.grafo.obtener_vecinos(vertice_actual).items():

                nueva_distancia = distancias[vertice_actual] + peso

                if nueva_distancia < distancias[vecino]:

                    distancias[vecino] = nueva_distancia

                    heapq.heappush(cola_prioridad, (nueva_distancia, vecino))

                    padres[vecino] = vertice_actual



        return None

#-------------------------------------------------------------------

    def clustering(self, k):

        # Obtener los vértices del grafo

        vertices = list(self.grafo.vertices.keys())

        # Obtener las posiciones de los vértices (simplemente usaremos un índice para cada vértice)

        posiciones = np.arange(len(vertices)).reshape(-1, 1)

        # Inicializar y ajustar el modelo de KMeans

        kmeans = KMeans(n_clusters=k, random_state=0).fit(posiciones)

        # Obtener las etiquetas de los clusters

        etiquetas_clusters = kmeans.labels_

        # Asignar cada vértice a su respectivo cluster

        clusters = {cluster: [] for cluster in range(k)}

        for i, etiqueta in enumerate(etiquetas_clusters):

            clusters[etiqueta].append(vertices[i])

        return clusters

#-------------------------------------------------------------

# Ejemplo de uso

grafo = Grafo()

grafo.agregar_vertice("A")

grafo.agregar_vertice("B")

grafo.agregar_vertice("C")

grafo.agregar_vertice("D")

grafo.agregar_vertice("E")

grafo.agregar_vertice("F")



grafo.agregar_arista("A", "B", 5)

grafo.agregar_arista("B", "C", 3)

grafo.agregar_arista("C", "D", 7)

grafo.agregar_arista("B", "D", 6)

grafo.agregar_arista("A", "D", 10)

grafo.agregar_arista("D", "E", 8)

grafo.agregar_arista("D", "F", 6)

grafo.agregar_arista("B", "F", 12)

grafo.agregar_arista("A", "F", 18)



sistema_transporte = SistemaTransporte(grafo)



# Aplicar K-Means para agrupar los vértices en 3 clusters

k = 3

clusters = sistema_transporte.clustering(k)

print("Clusters resultantes:")

for cluster, vertices in clusters.items():

    print(f"Cluster {cluster+1}: {vertices}")

